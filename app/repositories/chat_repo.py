import uuid
from datetime import datetime, timezone
from typing import List, Optional, Tuple, Sequence, Any, Dict

from sqlalchemy import select, update, desc, func, Row, TextClause, text
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
import sqlalchemy.exc

from app.models.chat import ChatSession, ChatMessage, InteractionFeedback
import logging

logger = logging.getLogger(__name__)

# --- Custom Exceptions ---
class RepositoryError(Exception):
    """Base class for repository exceptions."""
    pass

class RecordNotFound(RepositoryError):
    """Indicates a requested record was not found."""
    pass

class SessionMismatchError(RepositoryError):
    """Indicates a mismatch between expected and actual session ID."""
    pass

class FeedbackIntegrityError(RepositoryError):
    """Indicates an integrity issue adding/updating feedback (e.g., conflict)."""
    pass
# --- End Custom Exceptions ---

async def get_or_create_session(
    db: AsyncSession,
    session_id: Optional[uuid.UUID],
    user_id: uuid.UUID,
    organization_id: str
) -> Tuple[Optional[ChatSession], bool]:
    """Gets an existing ChatSession if ID is provided and found, 
       or creates a new one if ID is None.

    Args:
        db: The AsyncSession instance.
        session_id: The existing session ID (if any). If provided but not found, returns None.
        user_id: The ID of the user.
        organization_id: The ID of the organization.

    Returns:
        A tuple containing the ChatSession object (or None if not found) 
        and a boolean indicating if it was created (True) or existing (False).
    """
    if session_id:
        # --- Session ID Provided: Attempt to Find --- #
        logger.debug(f"Attempting to find existing session: {session_id}")
        stmt = select(ChatSession).where(ChatSession.session_id == session_id)
        result = await db.execute(stmt)
        session = result.scalar_one_or_none()
        
        if session:
            # Found the session
            logger.debug(f"Found existing session: {session_id}")
            # Note: Authorization check (user_id, org_id match) should happen in the API layer
            session.updated_at = datetime.now(timezone.utc) # Update timestamp on access
            # No commit needed here, let the calling function handle transaction
            return session, False # Found, not created
        else:
            # Session ID was provided, but not found in DB
            logger.warning(f"Requested session_id {session_id} not found.")
            return None, False # Not found, not created
    else:
        # --- Session ID is None: Create New --- #
        logger.info(f"No session_id provided, creating new session for user {user_id}, org {organization_id}")
        try:
            new_session = ChatSession(
                user_id=user_id, 
                organization_id=organization_id
                # session_id is generated by default
            )
            db.add(new_session)
            await db.flush() # Get the generated session_id and defaults
            await db.refresh(new_session)
            logger.info(f"Created new chat session: {new_session.session_id}")
            return new_session, True # Created
        except Exception as e:
            logger.error(f"Failed to create new session for user {user_id}: {e}", exc_info=True)
            # Propagate error for the caller to handle
            raise RepositoryError("Failed to create new session in database.") from e

async def update_session_timestamp(
    db: AsyncSession,
    session_id: uuid.UUID
):
    """Updates the updatedAt timestamp for a given session."""
    stmt = (
        update(ChatSession)
        .where(ChatSession.session_id == session_id)
        .values(updated_at=datetime.now(timezone.utc))
        .execution_options(synchronize_session=False)
    )
    await db.execute(stmt)
    logger.debug(f"Updated timestamp for session {session_id}")

async def create_chat_session(db: AsyncSession, user_id: uuid.UUID, organization_id: str) -> ChatSession:
    """Creates a new chat session for a given user and organization."""
    try:
        new_session = ChatSession(
            session_id=uuid.uuid4(),
            user_id=user_id,
            organization_id=organization_id
        )
        db.add(new_session)
        await db.commit()
        logger.info(f"Created new chat session {new_session.session_id} for user {user_id}")
        return new_session
    except Exception as e:
        error_msg = f"Unexpected error creating chat session for user {user_id}: {e}"
        logger.error(error_msg, exc_info=True)
        raise RepositoryError(error_msg) from e

async def log_initial_chat_message(
    db: AsyncSession, 
    request_id: uuid.UUID, 
    session_id: str, 
    user_id: uuid.UUID,
    organization_id: str,
    user_content: Optional[str]
):
    """Logs the initial user message before agent response."""
    logger.debug(f"Logging initial user message for request {request_id} in session {session_id}")
    try:
        # Verify session exists and user is authorized (use string for session_id)
        session_stmt = select(ChatSession).where(
            ChatSession.session_id == uuid.UUID(session_id),
            ChatSession.user_id == user_id,
            ChatSession.organization_id == organization_id
        )
        result = await db.execute(session_stmt)
        session = result.scalar_one_or_none()
        if not session:
            raise RecordNotFound(f"Session {session_id} not found or access denied")

        # Create ChatMessage using Python attribute names (snake_case)
        message = ChatMessage(
            request_id=request_id,
            session_id=uuid.UUID(session_id),
            user_message_content=user_content,
            user_message_timestamp=datetime.now(timezone.utc),
            # Assistant fields initially null
            assistant_message_content=None,
            assistant_response_metadata=None,
            assistant_message_timestamp=None,
            prompt_tokens=None,
            completion_tokens=None,
        )
        db.add(message)
        await db.commit()
        logger.debug(f"Successfully logged initial message for request {request_id}")
    except RecordNotFound as e:
        logger.error(f"Record not found error logging initial message for request {request_id}: {e}")
        await db.rollback()
        # Re-raise or handle as appropriate for background tasks (logging might be sufficient)
        # For now, just log and let the task end.
    except Exception as e:
        error_msg = f"Unexpected error logging initial message for request {request_id}: {e}"
        logger.error(error_msg, exc_info=True)
        await db.rollback()
        # Raise a specific error for background task monitoring if needed
        # raise RepositoryError(error_msg) from e

async def log_complete_chat_message(
    db: AsyncSession, 
    request_id: uuid.UUID, 
    session_id: str, 
    user_id: uuid.UUID,
    organization_id: str,
    user_content: Optional[str], # Kept for context, though potentially redundant if initial log works
    assistant_content: Optional[str],
    prompt_tokens: Optional[int],
    completion_tokens: Optional[int],
    # metadata: Optional[Dict[str, Any]] = None # Add if needed
):
    """Updates or creates a chat message log with the assistant's response."""
    logger.debug(f"Logging complete message details for request {request_id}")
    try:
        # Find the existing message log created by log_initial_chat_message
        # Filter by request_id - this should be unique
        stmt = select(ChatMessage).where(ChatMessage.request_id == request_id)
        result = await db.execute(stmt)
        message = result.scalar_one_or_none()

        if message:
            # Verify session ID matches (sanity check)
            if message.session_id != uuid.UUID(session_id):
                 logger.error(f"Session ID mismatch for request {request_id}: Expected {session_id}, found {message.session_id} in DB.")
                 # Decide how to handle: error, overwrite, ignore?
                 # For now, log error and proceed with update based on request_id match.
            
            # Update existing message with assistant details
            logger.debug(f"Updating existing message log for request {request_id}")
            message.assistant_message_content = assistant_content
            message.assistant_message_timestamp = datetime.now(timezone.utc)
            message.prompt_tokens = prompt_tokens
            message.completion_tokens = completion_tokens
            # message.assistant_response_metadata = metadata # Add if metadata is passed
            db.add(message) # Add updated object to session
        else:
            # This case might happen if log_initial_chat_message failed silently
            # or if called directly without a prior initial log.
            # Log a warning and create a new record for robustness.
            logger.warning(f"Initial message log for request {request_id} not found. Creating new complete log.")
            
            # Need to re-verify session access if creating anew
            session_stmt = select(ChatSession).where(
                ChatSession.session_id == uuid.UUID(session_id),
                ChatSession.user_id == user_id,
                ChatSession.organization_id == organization_id
            )
            session_result = await db.execute(session_stmt)
            session = session_result.scalar_one_or_none()
            if not session:
                 raise RecordNotFound(f"Session {session_id} not found or access denied for creating new log entry.")

            new_message = ChatMessage(
                request_id=request_id,
                session_id=uuid.UUID(session_id),
                user_message_content=user_content, # Log user message here if creating anew
                user_message_timestamp=datetime.now(timezone.utc), # Approximate user time
                assistant_message_content=assistant_content,
                assistant_message_timestamp=datetime.now(timezone.utc),
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                # assistant_response_metadata=metadata # Add if needed
            )
            db.add(new_message)

        await db.commit()
        logger.debug(f"Successfully logged complete message details for request {request_id}")
    except RecordNotFound as e:
        logger.error(f"Record not found error logging completion for request {request_id}: {e}")
        await db.rollback()
    except Exception as e:
        error_msg = f"Unexpected error logging complete message for request {request_id}: {e}"
        logger.error(error_msg, exc_info=True)
        await db.rollback()
        # raise RepositoryError(error_msg) from e

async def get_messages_for_memory(db: AsyncSession, session_id: uuid.UUID, limit: int = 6) -> List[Tuple[str, str]]:
    """Retrieves the last N interaction pairs (user message, assistant message) for agent memory.
    
    Args:
        db: The AsyncSession instance.
        session_id: The session ID to retrieve messages for.
        limit: The maximum number of *messages* (not pairs) to retrieve. Should be even for pairs.

    Returns:
        A list of tuples, where each tuple is (user_message_content, assistant_message_content).
        Returns oldest pairs first.
    """
    if limit % 2 != 0:
        logger.warning(f"Memory limit {limit} is odd; fetching {limit+1} messages to ensure pair completion.")
        limit += 1
        
    stmt = (
        select(
            ChatMessage.user_message_content,
            ChatMessage.assistant_message_content
        )
        .where(ChatMessage.session_id == session_id)
        .where(ChatMessage.assistant_message_content.isnot(None))
        .order_by(desc(ChatMessage.user_message_timestamp))
        .limit(limit // 2)
    )
    result = await db.execute(stmt)
    pairs = [(row.user_message_content, row.assistant_message_content) for row in result.fetchall()]
    return pairs[::-1] 

async def get_session_history(
    db: AsyncSession,
    session_id: str,
    user_id: uuid.UUID,
    organization_id: str,
    limit: int = 10,
    offset: int = 0,
) -> Sequence[ChatMessage]:
    """Retrieves chat history for a given session, authorized for the user/org."""
    logger.debug(f"Retrieving history for session {session_id}, user {user_id}, org {organization_id}")
    try:
        session_uuid = uuid.UUID(session_id)
    except ValueError:
        raise RecordNotFound(f"Invalid session ID format: {session_id}")

    # Join ChatMessage with ChatSession to filter by user and org
    stmt = (
        select(ChatMessage)
        .join(ChatSession, ChatMessage.session_id == ChatSession.session_id) # Use snake_case for join
        .where(
            ChatMessage.session_id == session_uuid,
            ChatSession.user_id == user_id,
            ChatSession.organization_id == organization_id
        )
        .order_by(ChatMessage.created_at.asc()) # Order by creation time
        .limit(limit)
        .offset(offset)
    )

    try:
        result = await db.execute(stmt)
        messages = result.scalars().all()
        logger.debug(f"Retrieved {len(messages)} messages for session {session_id}")
        return messages
    except Exception as e:
        logger.error(f"Database error retrieving history for session {session_id}: {e}", exc_info=True)
        raise RepositoryError(f"Failed to retrieve chat history for session {session_id}.") from e

async def add_feedback(
    db: AsyncSession,
    request_id: uuid.UUID,
    session_id: uuid.UUID,
    user_id: uuid.UUID,
    organization_id: str,
    rating: int
) -> InteractionFeedback:
    """Adds or updates feedback for a given chat message request ID, ensuring user/session consistency."""
    logger.info(f"Adding feedback for request {request_id}, session {session_id}, user {user_id}, rating {rating}")
    try:
        # Query for the specific message, joining with session to verify ownership
        message_stmt = (
            select(ChatMessage)
            .join(ChatSession, ChatMessage.session_id == ChatSession.session_id)
            .where(
                ChatMessage.request_id == request_id,
                ChatMessage.session_id == session_id,
                ChatSession.user_id == user_id,
                ChatSession.organization_id == organization_id
            )
        )
        message_result = await db.execute(message_stmt)
        chat_message = message_result.scalar_one_or_none()
        if not chat_message:
            logger.warning(f"Feedback rejected: ChatMessage not found or not authorized for request {request_id}, session {session_id}, user {user_id}, org {organization_id}")
            raise RecordNotFound(f"Original interaction not found or not authorized for request ID {request_id}.")

        # Check for existing feedback for this specific request ID using the correct attribute name
        feedback_stmt = select(InteractionFeedback).where(InteractionFeedback.request_id == request_id)
        feedback_result = await db.execute(feedback_stmt)
        existing_feedback = feedback_result.scalar_one_or_none()

        if existing_feedback:
            # Compare UUID objects directly (DB is UUID, model is UUID, input is UUID)
            if existing_feedback.user_id != user_id:
                 logger.error(f"Feedback integrity issue: Attempt by user {user_id} to update feedback originally submitted by user {existing_feedback.user_id} for request {request_id}.")
                 raise RecordNotFound("Feedback record conflict or mismatch.")
            logger.info(f"Updating existing feedback for request {request_id}")
            existing_feedback.rating = rating
            feedback_to_return = existing_feedback
            db.add(feedback_to_return)
        else:
            logger.info(f"Creating new feedback for request {request_id}")
            # Create InteractionFeedback object - use model attribute names
            new_feedback = InteractionFeedback(
                feedback_id=uuid.uuid4(),
                request_id=request_id,
                user_id=user_id,
                rating=rating,
            )
            db.add(new_feedback)
            feedback_to_return = new_feedback
            
        # Commit transaction after adding/updating
        await db.commit()
        logger.info(f"Successfully submitted feedback for request {request_id}")
        return feedback_to_return
    except ValueError:
        await db.rollback()
        logger.warning(f"Invalid session ID format provided for feedback: {session_id}")
        raise RecordNotFound("Invalid session ID format provided.")
    except RecordNotFound as e:
        await db.rollback()
        raise e
    except sqlalchemy.exc.IntegrityError as e:
        await db.rollback()
        logger.error(f"Database integrity error submitting feedback for request {request_id}: {e}", exc_info=True)
        raise FeedbackIntegrityError("Failed to submit feedback due to data consistency issue.") from e
    except sqlalchemy.exc.SQLAlchemyError as e:
        await db.rollback()
        logger.error(f"Database error submitting feedback for request {request_id}: {e}", exc_info=True)
        raise RepositoryError("Failed to submit feedback due to database error.") from e
    except Exception as e:
        await db.rollback()
        logger.error(f"Unexpected error submitting feedback for request {request_id}: {e}", exc_info=True)
        raise RepositoryError("An unexpected error occurred while submitting feedback.") from e
